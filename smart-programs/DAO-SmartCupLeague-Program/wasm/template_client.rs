// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct TemplateFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}

impl<R> TemplateFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}

impl<R: Remoting + Clone> traits::TemplateFactory for TemplateFactory<R> {
    type Args = R::Args;
    fn new(
        &self,
        market_contract: ActorId,
        kyc_contract: ActorId,
    ) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, template_factory::io::New>::new(
            self.remoting.clone(),
            (market_contract, kyc_contract),
        )
    }
}

pub mod template_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());

        impl New {
            #[allow(dead_code)]
            pub fn encode_call(market_contract: ActorId, kyc_contract: ActorId) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(market_contract, kyc_contract))
            }
        }

        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (ActorId, ActorId);
            type Reply = ();
        }
    }
}
pub struct Service<R> {
    remoting: R,
}

impl<R> Service<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}

impl<R: Remoting + Clone> traits::Service for Service<R> {
    type Args = R::Args;
    fn create_proposal(
        &mut self,
        kind: ProposalKind,
        description: String,
    ) -> impl Call<Output = DaoEvent, Args = R::Args> {
        RemotingAction::<_, service::io::CreateProposal>::new(
            self.remoting.clone(),
            (kind, description),
        )
    }
    fn execute(&mut self, proposal_id: u64) -> impl Call<Output = Vec<DaoEvent>, Args = R::Args> {
        RemotingAction::<_, service::io::Execute>::new(self.remoting.clone(), proposal_id)
    }
    fn finalize_proposal(
        &mut self,
        proposal_id: u64,
    ) -> impl Call<Output = DaoEvent, Args = R::Args> {
        RemotingAction::<_, service::io::FinalizeProposal>::new(self.remoting.clone(), proposal_id)
    }
    fn set_market_contract(
        &mut self,
        new_market: ActorId,
    ) -> impl Call<Output = DaoEvent, Args = R::Args> {
        RemotingAction::<_, service::io::SetMarketContract>::new(self.remoting.clone(), new_market)
    }
    fn set_owner(&mut self, new_owner: ActorId) -> impl Call<Output = DaoEvent, Args = R::Args> {
        RemotingAction::<_, service::io::SetOwner>::new(self.remoting.clone(), new_owner)
    }
    fn vote(
        &mut self,
        proposal_id: u64,
        choice: VoteChoice,
    ) -> impl Call<Output = DaoEvent, Args = R::Args> {
        RemotingAction::<_, service::io::Vote>::new(self.remoting.clone(), (proposal_id, choice))
    }
    fn query_proposal(
        &self,
        proposal_id: u64,
    ) -> impl Query<Output = Option<Proposal>, Args = R::Args> {
        RemotingAction::<_, service::io::QueryProposal>::new(self.remoting.clone(), proposal_id)
    }
    fn query_proposals(&self) -> impl Query<Output = Vec<Proposal>, Args = R::Args> {
        RemotingAction::<_, service::io::QueryProposals>::new(self.remoting.clone(), ())
    }
    fn query_state(&self) -> impl Query<Output = IoDaoState, Args = R::Args> {
        RemotingAction::<_, service::io::QueryState>::new(self.remoting.clone(), ())
    }
    fn query_vote(
        &self,
        proposal_id: u64,
        voter: ActorId,
    ) -> impl Query<Output = Option<VoteChoice>, Args = R::Args> {
        RemotingAction::<_, service::io::QueryVote>::new(
            self.remoting.clone(),
            (proposal_id, voter),
        )
    }
}

pub mod service {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct CreateProposal(());

        impl CreateProposal {
            #[allow(dead_code)]
            pub fn encode_call(kind: super::ProposalKind, description: String) -> Vec<u8> {
                <CreateProposal as ActionIo>::encode_call(&(kind, description))
            }
        }

        impl ActionIo for CreateProposal {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 56, 67, 114, 101, 97, 116, 101, 80, 114, 111,
                112, 111, 115, 97, 108,
            ];
            type Params = (super::ProposalKind, String);
            type Reply = super::DaoEvent;
        }
        pub struct Execute(());

        impl Execute {
            #[allow(dead_code)]
            pub fn encode_call(proposal_id: u64) -> Vec<u8> {
                <Execute as ActionIo>::encode_call(&proposal_id)
            }
        }

        impl ActionIo for Execute {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 28, 69, 120, 101, 99, 117, 116, 101,
            ];
            type Params = u64;
            type Reply = Vec<super::DaoEvent>;
        }
        pub struct FinalizeProposal(());

        impl FinalizeProposal {
            #[allow(dead_code)]
            pub fn encode_call(proposal_id: u64) -> Vec<u8> {
                <FinalizeProposal as ActionIo>::encode_call(&proposal_id)
            }
        }

        impl ActionIo for FinalizeProposal {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 64, 70, 105, 110, 97, 108, 105, 122, 101, 80,
                114, 111, 112, 111, 115, 97, 108,
            ];
            type Params = u64;
            type Reply = super::DaoEvent;
        }
        pub struct SetMarketContract(());

        impl SetMarketContract {
            #[allow(dead_code)]
            pub fn encode_call(new_market: ActorId) -> Vec<u8> {
                <SetMarketContract as ActionIo>::encode_call(&new_market)
            }
        }

        impl ActionIo for SetMarketContract {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 68, 83, 101, 116, 77, 97, 114, 107, 101, 116,
                67, 111, 110, 116, 114, 97, 99, 116,
            ];
            type Params = ActorId;
            type Reply = super::DaoEvent;
        }
        pub struct SetOwner(());

        impl SetOwner {
            #[allow(dead_code)]
            pub fn encode_call(new_owner: ActorId) -> Vec<u8> {
                <SetOwner as ActionIo>::encode_call(&new_owner)
            }
        }

        impl ActionIo for SetOwner {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 32, 83, 101, 116, 79, 119, 110, 101, 114,
            ];
            type Params = ActorId;
            type Reply = super::DaoEvent;
        }
        pub struct Vote(());

        impl Vote {
            #[allow(dead_code)]
            pub fn encode_call(proposal_id: u64, choice: super::VoteChoice) -> Vec<u8> {
                <Vote as ActionIo>::encode_call(&(proposal_id, choice))
            }
        }

        impl ActionIo for Vote {
            const ROUTE: &'static [u8] =
                &[28, 83, 101, 114, 118, 105, 99, 101, 16, 86, 111, 116, 101];
            type Params = (u64, super::VoteChoice);
            type Reply = super::DaoEvent;
        }
        pub struct QueryProposal(());

        impl QueryProposal {
            #[allow(dead_code)]
            pub fn encode_call(proposal_id: u64) -> Vec<u8> {
                <QueryProposal as ActionIo>::encode_call(&proposal_id)
            }
        }

        impl ActionIo for QueryProposal {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 52, 81, 117, 101, 114, 121, 80, 114, 111, 112,
                111, 115, 97, 108,
            ];
            type Params = u64;
            type Reply = Option<super::Proposal>;
        }
        pub struct QueryProposals(());

        impl QueryProposals {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <QueryProposals as ActionIo>::encode_call(&())
            }
        }

        impl ActionIo for QueryProposals {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 56, 81, 117, 101, 114, 121, 80, 114, 111, 112,
                111, 115, 97, 108, 115,
            ];
            type Params = ();
            type Reply = Vec<super::Proposal>;
        }
        pub struct QueryState(());

        impl QueryState {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <QueryState as ActionIo>::encode_call(&())
            }
        }

        impl ActionIo for QueryState {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 40, 81, 117, 101, 114, 121, 83, 116, 97, 116,
                101,
            ];
            type Params = ();
            type Reply = super::IoDaoState;
        }
        pub struct QueryVote(());

        impl QueryVote {
            #[allow(dead_code)]
            pub fn encode_call(proposal_id: u64, voter: ActorId) -> Vec<u8> {
                <QueryVote as ActionIo>::encode_call(&(proposal_id, voter))
            }
        }

        impl ActionIo for QueryVote {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 36, 81, 117, 101, 114, 121, 86, 111, 116, 101,
            ];
            type Params = (u64, ActorId);
            type Reply = Option<super::VoteChoice>;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum ServiceEvents {
            Seeded((ActorId, ActorId)),
            ProposalCreated((u64, ActorId)),
            Voted((u64, ActorId, VoteChoice)),
            ProposalFinalized((u64, ProposalStatus)),
            ProposalExecuted(u64),
            MarketCallDispatched(u64),
            GovernanceParamUpdated,
        }
        impl EventIo for ServiceEvents {
            const ROUTE: &'static [u8] = &[28, 83, 101, 114, 118, 105, 99, 101];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[24, 83, 101, 101, 100, 101, 100],
                &[
                    60, 80, 114, 111, 112, 111, 115, 97, 108, 67, 114, 101, 97, 116, 101, 100,
                ],
                &[20, 86, 111, 116, 101, 100],
                &[
                    68, 80, 114, 111, 112, 111, 115, 97, 108, 70, 105, 110, 97, 108, 105, 122, 101,
                    100,
                ],
                &[
                    64, 80, 114, 111, 112, 111, 115, 97, 108, 69, 120, 101, 99, 117, 116, 101, 100,
                ],
                &[
                    80, 77, 97, 114, 107, 101, 116, 67, 97, 108, 108, 68, 105, 115, 112, 97, 116,
                    99, 104, 101, 100,
                ],
                &[
                    88, 71, 111, 118, 101, 114, 110, 97, 110, 99, 101, 80, 97, 114, 97, 109, 85,
                    112, 100, 97, 116, 101, 100,
                ],
            ];
            type Event = Self;
        }

        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<ServiceEvents> {
            RemotingListener::<_, ServiceEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ProposalKind {
    SetFeeBps {
        new_fee_bps: u128,
    },
    SetFinalPrizeBps {
        new_final_prize_bps: u128,
    },
    SetMaxPayoutChunk {
        new_max_payout_chunk: u128,
    },
    AddPhase {
        name: String,
        start_time: u64,
        end_time: u64,
    },
    AddMatch {
        phase: String,
        home: String,
        away: String,
        kick_off: u64,
    },
    SetQuorum {
        new_quorum_bps: u16,
    },
    SetVotingPeriod {
        new_voting_period: u64,
    },
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum VoteChoice {
    Yes,
    No,
    Abstain,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ProposalStatus {
    Active,
    Defeated,
    Succeeded,
    Executed,
    Expired,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Proposal {
    pub id: u64,
    pub proposer: ActorId,
    pub kind: ProposalKind,
    pub description: String,
    pub start_time: u64,
    pub end_time: u64,
    pub yes: u32,
    pub no: u32,
    pub abstain: u32,
    pub status: ProposalStatus,
    pub executed: bool,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct IoDaoState {
    pub owner: ActorId,
    pub market_contract: ActorId,
    pub kyc_contract: Option<ActorId>,
    pub quorum_bps: u16,
    pub voting_period: u64,
    pub proposal_count: u64,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait TemplateFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            market_contract: ActorId,
            kyc_contract: ActorId,
        ) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Service {
        type Args;
        fn create_proposal(
            &mut self,
            kind: ProposalKind,
            description: String,
        ) -> impl Call<Output = DaoEvent, Args = Self::Args>;
        fn execute(
            &mut self,
            proposal_id: u64,
        ) -> impl Call<Output = Vec<DaoEvent>, Args = Self::Args>;
        fn finalize_proposal(
            &mut self,
            proposal_id: u64,
        ) -> impl Call<Output = DaoEvent, Args = Self::Args>;
        fn set_market_contract(
            &mut self,
            new_market: ActorId,
        ) -> impl Call<Output = DaoEvent, Args = Self::Args>;
        fn set_owner(
            &mut self,
            new_owner: ActorId,
        ) -> impl Call<Output = DaoEvent, Args = Self::Args>;
        fn vote(
            &mut self,
            proposal_id: u64,
            choice: VoteChoice,
        ) -> impl Call<Output = DaoEvent, Args = Self::Args>;
        fn query_proposal(
            &self,
            proposal_id: u64,
        ) -> impl Query<Output = Option<Proposal>, Args = Self::Args>;
        fn query_proposals(&self) -> impl Query<Output = Vec<Proposal>, Args = Self::Args>;
        fn query_state(&self) -> impl Query<Output = IoDaoState, Args = Self::Args>;
        fn query_vote(
            &self,
            proposal_id: u64,
            voter: ActorId,
        ) -> impl Query<Output = Option<VoteChoice>, Args = Self::Args>;
    }
}
